1.视图:
数据库对象之一
在SQL 语句中体现的角色与表相同。
但视图并不是一张真实存在的表，它只是对应了一条SELECT
语句查询的结果集。
使用视图可以重用子查询，并简化SQL语句的复杂度。

创建包含10号部门员工的信息的视图
CREATE VIEW V_EMP_10
AS
SELECT EMPNO,ENAME,SAL,DEPTNO
FROM EMP
WHERE DEPTNO=10

SELECT *FROM v_EMP_10
DESC v_emp_10

视图对应的子查询字段可以使用别名，
那么该视图对应的字段名就是这个别名了，
若字段含有函数或表达式，必须指定别名。
CREATE OR REPLACE VIEW V_EMP_10
AS
SELECT EMPNO ID ,ENAME NAME,DEPTNO,SAL SALARY
FROM EMP
WHERE DEPTNO=10
SELECT id from v_emp_10

对视图进行DML操作
对视图进行DML操作就是对视图数据来源的基础进行的。
只能对简单视图进行DML操作，复杂视图不允许使用DML操作。
对简单视图进行DML操作时，也不能违背基表的约束条件。

INSERT INTO V_EMP_10(ID,NAME,DEPTNO,SALARY)
VALUES (1000,'JaaCK',10，5000)
SELECT *FROM V_EMP_10
SELECT *FROM EMP

当通过视图插入一条视图本身不可见的数据时，就是对基表的污染。
插入会造成污染，修改也会造成，但是删除不会造成。
INSERT INTO V_EMP_10(ID,NAME,DEPTNO,SALARY)
VALUES(1000，'JACK',20，5000)
SELECT *FROM V_EMP_10
SELECT *FROM EMP

UPDATE V_EMP_10
SET DEPTNO=20
删除不会污染
DELETE FROM V_EMP_10 --删除只会对视图中有的列删除 换成20不会删除
WHERE DEPTNO=10

对视图添加检查选项
WITH CHECK OPTION
当视图添加了检查选项后，那么对视图进行行插入或修改
操作时，视图要求：
插入时：插入的数据视图必须对其可见
修改时：修改后视图必须对数据可见

CREATE OR REPLACE VIEW V_EMP_10
AS
  SELECT EMPNO ID,ENAME NAME, SAL SALARY, DEPTNO
  FROM EMP
WHERE DEPTNO=10
WITH CHECK OPTION --删除不影响

为视图添加只读选项
WITH READ ONLY
当一个视图添加了只读选项后，该视图不允许进行DML操作。
CREATE OR REPLACE VIEW V_EMP_10
AS
  SELECT EMPNO ID,ENAME NAME ,SAL SALARY,DEPTNO
  FROM EMP
WHERE DEPTNO=10
WITH READ ONLY

查看曾经创建的数据库对象（表和视图） 
SELECT OBJECT_NAME
FROM USER_OBJECTS
WHERE OBJECT_TYPE='VIEW'

SELECT TEXT FROM USER_VIEWS--查看视图代码语句

SELECT TABLE_NAME FROM USER_TABLES

复杂视图
查询语句含有函数，表达式，分组，去重
多表关联查询
复杂视图不能进行DML。
创建一个各部门工资情况的视图。
CREATE VIEW V_DEPT_SAL
AS SELECT D.DEPTNO,D.DNAME,
           MIN(E.SAL) MIN_SAL
          ,MAX(E.SAL) MAX_SAL
          ,AVG(E.SAL) AVG_SAL
          ,SUM(E.SAL) SUM_SAL
   FROM EMP E,DEPT D
   WHERE E.DEPTNO=D.DEPTNO
   GROUP BY D.DEPTNO,D.DNAME
   
SELECT *FROM V_DEPT_SAL    
查找高于部门平均工资的员工？
SELECT E.ENAME,E.SAL,E.DEPTNO
FROM EMP E, V_DEPT_SAL D
WHERE E.DEPTNO=D.DEPTNO
AND   E.SAL>D.AVG_SAL
 
删除视图
DROP VIEW V_EMP_10
SELECT *FROM V_EMP_10
删除视图中的数据会将对应的基表数据删除，
但是删除视图本身并不会对基表数据产生任何的影响。

序列
序列也是数据库对象之一
序列是用来生成一系列数字的。
序列通常为表的主键提供值使用。

CREATE SEQUENCE SEQ_EMP_ID
START WITH 1
INCREMENT BY 1

序列支持两个伪列
NEXTVAL：使序列生成下一个数字（用最后生成的数字加上步长得到），
新创建的序列则返回START WITH 指定的数字。
序列是不能回退的，所以通过NEXTVAL获取了下一个数字后就无法再获取之前生成的
数字了。
CURRVAL：获取序列生成的最后一个数字，无论调用多少次
都不会导致序列生成新的数字，但是新创建的序列至少调用一次
NEXTVAL后才可以开始使用CURRVAL。

SELECT SEQ_EMP_ID.NEXTVAL
FROM DUAL

SELECT SEQ_EMP_ID.CURRVAL
FROM DUAL

使用SEQ_EMP_ID为EMP表的主键
生成值
INSERT INTO EMP
(EMPNO,ENAME,JOB,SAL,DEPTNO)
VALUES
(SEQ_EMP_ID.NEXTVAL,'JACK','SALESMAN',5000，10)

SELECT *FROM EMP
删除序列
DROP SEQUENCE SEQ_EMP_ID

UUID
字符串类型的主键值，32位不重复字符串
ORACLE提供了一个函数可以生成UUID
SELECT SYS_GUID() FROM DUAL
索引
CREATE INDEX IDX_EMP_ENAME ON EMP(ENAME)
多列索引
CREATE INDEX IDX_EMP_SAL_JOB ON EMP(JOB,SAL);
SELECT EMPNO,ENAME,SAL,JOB FROM EMP
ORDER BY JOB,SAL ---注意顺序要和索引顺序一致，否则无效果
基于函数的索引
CREATE INDEX EMP_ENAME_UOOER_IDX
ON EMP(UPPER(ENAME))
当做下面查询时，会调用上面索引
SELECT *FROM EMP
WHERE UPPER(ENAME)='KING'
更新索引
ALTER INDEX IDX_EMP_ENAME REBUILD
删除索引
DROP INDEX IDX_EMP_ENAME;
约束
CREATE TABLE EMPLOYEES(
  EID NUMBER(6),
  NAME VARCHAR2(30) not null,
  salary NUMBER(7,2),
  hiredate DATE CONSTRAINT EMPLOYEES_HIREDATE_NN NOT NULL
)
ALTER TABLE EMPLOYEES
MODIFY(EID NUMBER(6) NOT NULL)

ALTER TABLE EMPLOYEES
MODIFY(EID NUMBER(6)NULL)

DESC employees
SELECT *FROM EMPLOYEES

唯一性约束
当某个字段使用了唯一性约束后，该字段的值在表中
是不允许有重复值的，但是NULL除外。
CREATE TABLE EMPLOYEES1(
  EID NUMBER(6) UNIQUE,
  NAME VARCHAR2(30),
  EMAIL VARCHAR2(50),
  SALARY NUMBER(7，2),
  HIREDATE DATE,
  CONSTRAINT EMPLOYEES_EMAIL_UK UNIQUE (EMAIL)--创建完后再加约束 表约束
)
DESC EMPLOYEES1
--插入重复EID和email 报错
INSERT INTO EMPLOYEES1(EID,NAME,EMAIL)
VALUES (2，'JACK','JACK@QQ.COM')
INSERT INTO EMPLOYEES1(EID,NAME,EMAIL)
VALUES(NULL,'JACK',NULL)
SELECT *FROM EMPLOYEES1
DELETE FROM EMPLOYEES1

ALTER TABLE EMPLOYEES1
ADD CONSTRAINT EMPLOYEES_NAME_UK UNIQUE(NAME);
DESC EMPLOYEES1
主键约束
非空且唯一
CREATE TABLE EMPLOYEES2(
EID NUMBER(6)PRIMARY KEY,
NAME VARCHAR2(30),
EMAIL VARCHAR2(50),
SALARY NUMBER(7，2),
HIREDATE DATE
);
INSERT INTO EMPLOYEES2
(EID,NAME)
VALUES(1，'JACK')

INSERT INTO EMPLOYEES2
(EID,NAME)
VALUES(2，'JACK')

INSERT INTO EMPLOYEES2
(EID,NAME)
VALUES(NULL，'JACK')

SELECT *FROM EMPLOYEES2

ALTER TABLE EMPLOYEES2
ADD CONSTRAINT EMPLOYEES2_SALARY_CHECK
CHECK(SALARY>2000)
ALTER TABLE EMPLOYEES2
ADD CONSTRAINT EMPLOYEES2_SALARY_CHECK2
CHECK(SALARY<5000)


INSERT INTO EMPLOYEES2(EID,NAME,SALARY)
VALUES(1236，'JACK',2500)

INSERT INTO EMPLOYEES2(EID,NAME,SALARY)
VALUES(3，'JACK',2000)--小于2000不能添加

UPDATE EMPLOYEES2 SET SALARY=4500
WHERE EID=1236--违反约束条件不能更新


